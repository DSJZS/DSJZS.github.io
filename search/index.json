[{"content":"前言 唉，元师傅你的博客不是一个技术博客吗，怎么开一个新系列教做饭了？\n也是没办法，为了提高生活质量，做饭也是程序员必须掌握的“语言”啊！🧑‍🍳\n本人也是于最近开始学做饭了，鉴于技术原因，本人提到的做法不保障读者能完全复现或者能安全食用，出问题了本人不负责并且第一个跑。🏃\n食材准备 手工面条(也就是成型的分开的面条)或者碱水挂面(要煮成型) 鸡蛋等配菜(看着加，本教程默认配菜只有鸡蛋) 油 老抽 盐 胡椒(可以不要) 制作步骤 ① 将面条煮到熟 🍜 如果是成型的手工面特别简单，煮到八分熟就行，然后捞出来；如果是碱水挂面则需要煮到成型，然后看情况在粘粘前捞出(无论是那种面，煮面时可以加一点盐，这样煮面更快，煮出来的面更加劲道)。把面捞出来后倒入装满冷水的碗，然后用筷子分开粘黏的面条，等待冷却后快速沥干水分，防止成“泡面”了。最后加入老抽拌匀上色，拌的时候还可以加点食用油进一步防止面条粘黏。\n② 搅拌鸡蛋液 🥚🥄 敲 1 ~ 2 个鸡蛋，将蛋液倒入一个碗中并用筷子或者专门的工具搅拌均匀备用。\n③ 炒鸡蛋 🍳 开火热锅，然后加足够的油(很关键不然粘锅)，接着加盐并倒入搅拌完成的鸡蛋液。蛋液入锅后快速用锅铲沿着一个方向搅拌蛋液弄散鸡蛋。等鸡蛋成型后关火进入下一步。\n④ 炒面 🪏 此时锅里有上一步炒好的鸡蛋，观察锅的表面是否比较“油”，如果没有油膜必须加油(很关键不然粘锅)。倒入准备好的面条并开大火翻锅开炒！炒到差不多熟后可以根据口味自己额外加点盐或者胡椒啥的然后继续炒到完全熟之后出锅！。\n总结 ☝️🤓 只能说面确实是炒出来的，本人多次“仿真”外加“物理机实验”都没问题，但不代表没有BUG，也不保障能在不同“运行环境”下运行，如果按照这个开源流程“炸机”了本人概不负责。\n","date":"2026-01-25T21:53:45+08:00","permalink":"https://DSJZS.github.io/p/%E5%B1%8B%E9%87%8C%E9%A3%9F%E7%A0%941%E7%82%92%E9%9D%A2/","title":"屋里食研(1)：炒面"},{"content":"前言 又一个新系列(坑)开始了！这个系列我会发布一些自己学习Linux开发过程中写下的笔记。\n第一篇笔记便是如何愉快(?)的在Linux环境下进行Debug工作(以C语言举例)。\n使用的主要工具为 systemd-coredump、GDB。\nCore dump 介绍 Core Dump，中文译名为 内核转储 或者 核心转储。\nCore Dump 是程序崩溃时，内核将进程的内存镜像、寄存器状态、文件描述符等信息写入磁盘的文件。\n简单地说，其相当于程序崩溃瞬间的“快照”，可用于事后调试（如通过 gdb 分析崩溃原因）。\nCore dump 应仅与受信任的方共享，因为它们可能包含敏感数据（如密码或加密密钥）。\nCore dump 通常不被普通用户使用，但开发人员可以将其作为程序崩溃时状态的事后快照，特别是当故障难以可靠复现时。\n可以通过 systemd-coredump 等工具进行管理。本文基于 systemd-coredump 演示。\n如果你已经有了心仪的工具，可以直接跳过下一小结。\nsystemd-coredump 介绍 systemd-coredump 是 systemd 的一个组件，用于管理 Core dump 文件。\n可以通过如下的方式查看当前设备的核心转储处理方式，\n1 2 ~$ cat /proc/sys/kernel/core_pattern |/usr/lib/systemd/systemd-coredump %P %u %g %s %t 9223372036854775808 %h %d 如果在你的电脑上没有显示管道传输到 systemd-coredump 中，说明你用的不是 systemd-coredump。\n一般来说，会出现在一些比较有想法的Linux版本中，比如Ubuntu24.04，其结果可能会如下：\n1 2 ~$ cat /proc/sys/kernel/core_pattern |/usr/share/apport/apport -p%p -s%s -c%c -d%d -P%P -u%u -g%g -F%F -- %E 如果你像我一样更喜欢用 systemd-coredump，而非 apport ，你可以执行下面的命令。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 # 彻底关闭 apport # 1. 删除 apport 可能产生的崩溃报告 ~$ rm -rf /var/crash/* # 2. 编辑如下的文件，将 enabled 的值修改为 0 ~$ vim /etc/default/apport enabled=0 # 3. 关闭 apport 的启动 ~$ systemctl stop apport ~$ systemctl disable apport # 安装 systemd-coredump （如果你的设备上没有） ~$ sudo apt install systemd-coredump # 此时执行一开始的命令，即可看到变化(如果没有请自行修改) ~$ cat /proc/sys/kernel/core_pattern |/usr/lib/systemd/systemd-coredump %P %u %g %s %t 9223372036854775808 %h %d 在 systemd 系统中，systemd-coredump 的行为由 /etc/systemd/coredump.conf 或 /etc/systemd/coredump.conf.d/*.conf 控制。\n根据手册，建议在后者，也就是 /etc/systemd/coredump.conf.d/*.conf 中进行配置，如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 ~$ cat /etc/systemd/coredump.conf.d/custom.conf [Coredump] # 保存到磁盘 Storage=external # 启用xz压缩以节省空间 Compress=yes # 核心文件处理最大限制 ProcessSizeMax=2G # 核心文件的最大存储限制与日志的最大存储限制 ExternalSizeMax=2G JournalSizeMax=767M # 核心存储目录最多可以使用多少磁盘空间 # 分区上至少保存多少空闲空间 MaxUse=5G KeepFree=1G 具体的配置可以查看手册 coredump.conf(5) 。\n创建完成后可以执行重启守护程序与单元的命令，如下：\n1 2 ~$ sudo systemctl daemon-reload ~$ sudo systemctl restart systemd-coredump.socket 值得注意的是一些文章可能会说还要执行 ulimit -c 命令查看是否有进程级限制，\n但是据我查询手册 core(5)，发现并非如此。手册的原文如下:\nThe RLIMIT_CORE (core file size) or RLIMIT_FSIZE (file size) resource limits for the process are set to zero; see getrlimit(2) and the documentation of the shell's ulimit command (limit in csh(1)). However, RLIMIT_CORE will be ignored if the system is configured to pipe core dumps to a program.\n也就是我们将 coredump 管道传输到 systemd-coredump 等程序，Linux 内核本身会忽略 ulimit 设置。\n实际上传统的配置方法才会受此影响，具体可以查阅我给出的参考文章\n如果你不想让 systemd-coredump 处理 Core dump 文件，那么应该如下设置配置文件：\n1 2 3 4 ~$ cat /etc/systemd/coredump.conf.d/custom.conf [Coredump] Storage=none ProcessSizeMax=0 如果你配置好了，那么设备上的 Core dump 文件默认会保存于 /var/lib/systemd/coredump/ 目录下。\n不过一般通过 systemd-coredump 的管理工具 coredumpctl 查询，如下：\n1 2 3 4 5 coredumpctl list TIME PID UID GID SIG COREFILE EXE SIZE Sun 2026-01-11 17:51:40 CST 359684 1000 1000 SIGSEGV present /home/bigshot/project/c/error/test.exe 19.4K Sun 2026-01-11 18:06:00 CST 370138 1000 1000 SIGSEGV present /home/bigshot/project/c/error/test.exe 19.3K Sun 2026-01-11 18:25:08 CST 378385 1000 1000 SIGSEGV present /home/bigshot/project/c/error/test.exe 19.3K 具体的用法可以通过命令coredumpctl help或者手册 coredumpctl(1) 查询。\nGDB 介绍 GDB (GNU Debugger) 应该是 Linux 系统下最常用的程序调试工具了，程序员们都或多或少用过它或者基于它的工具进行Debug。\n如果想要使用GDB进行调试，那么编译C代码时必须使用 debug 模式（或者尽可能保留Debug信息），比如使用 gcc 的 -g 选项。\n使用 gdb \u0026lt;可执行文件\u0026gt; 即可开启对指定程序的Debug，\nGDB初始化文件 和shell类似，GDB也有初始化文件，不同的是GDB的初始化文件使用GDB命令。\n其会按照以下的顺序读取初始化文件，并依次执行：\n$HOME/.gdbinit 运行命令行选项 ./.gdbinit 通过-x选项给出的命令文件 此外通过 source 命令也能引入文件。\n常用的GDB命令 具体如下(部分不常用的命令或格式省略)：\n举例演示的补充说明跳转到下一小节。\n命令 简写 作用 跳转目录 info inf i 查询有关信息 info inf i 信息 sharedlibrary share 手动添加共享库(动态库) sharedlibrary share 手动添加共享库(动态库) break brea bre br b 设置断点 break brea bre br b 断点 hbreak tbreak thbreak 设置其它断点 hbreak tbreak thbreak 其它断点 clear cl 清除断点 clear cl 清除断点 enable en 启用断点 enable en / disable disa dis 启用/禁用断点 disable disa dis 禁用断点 enable disable 启用/禁用断点 conditon 断点条件的添加(替换)与删除 conditon 断点条件的添加(替换)与删除 run r (重头开始)运行 run r 运行 start (重头开始)运行到main函数 start 开始 backtrace bt where 显示栈帧 backtrace bt where 显示栈帧 print p inspect 显示变量 print p 显示变量 x 显示内容中的内容 x 显示内存 disassemble disas 反汇编 disassemble disas 反汇编 next n 单步(不进入函数内部) next n 单步(不进入函数内部) step s 单步(进入函数内部) step s 单步(进入函数内部) ignore 忽略断点、监视点、捕获点 ignore 忽略断点、监视点、捕获点 continue c fg 继续运行 continue c fg 继续运行 finish fin 执行完当前函数 finish fin 执行完当前函数 until u 运行到某一位置 until u 运行到某一位置 watch 添加监视点(改变) watch awatch rwatch 监视点 awatch 添加监视点(被访问、改变) watch awatch rwatch 监视点 rwatch 添加监视点(被访问) watch awatch rwatch 监视点 delete d del 删除断点和监视点 delete d del 删除断点和监视点 set 设置值 set 设置值 generate-core-file gcore 生成Core dump文件 generate-core-file gcore 生成Core dump文件 attach 调试(附加到)已启动进程 attach detach 调试(附加到)和脱离已启动进程 detach 脱离已启动进程 attach detach 调试(附加到)和脱离已启动进程 commands 断点命令 commands 断点命令 list l 显示函数或行 list l 显示函数或行 help h 帮助文档 help h 帮助文档 show 显示数据 show 显示数据 define 命令定义 define 命令定义 / document 命令说明 document 命令说明 define 命令定义 / document 命令说明 source 引入初始化文件 source 引入初始化文件 举例演示的补充说明 演示程序如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 ~$ cat main.c #include \u0026lt;stdio.h\u0026gt; void deepdark() { printf(\u0026#34;deepdark\\n\u0026#34;); } void unhappy() { printf(\u0026#34;unhappy\\n\u0026#34;); deepdark(); } void happy() { int i = 5; printf(\u0026#34;happyi %d\\n\u0026#34;, i); unhappy(); } int main() { printf(\u0026#34;this is a gdb test program\\n\u0026#34;); happy(); return 0; } ~$ gcc main.c -o gdb_test.exe -g ~$ ls gdb_test.exe main.c gdb_test.exe main.c info inf i 信息 格式 同义 作用 info break info breakpoints, info b 查看当前设置的所有断点 info stack info s 同 backtrace info registers info reg 显示寄存器 info proc 显示进程信息 info sharedlibrary info share, info shared 显示已加载的共享库(动态库)的状态 info set 同 show sharedlibrary share 手动添加共享库(动态库) 格式：sharedlibrary 共享库(动态库)路径\n手动添加共享库(动态库)到当前进程。\nbreak brea bre br b 断点 断点的设置：\n格式 作用 break 函数名 在当前文件指定函数处打断点 break 行号 在当前文件指定行打断点 break 文件名:行号 在指定文件的指定行处打断点 break 文件名:函数名 在指定文件的指定函数处处打断点 break +偏移量 在当前暂停位置往后几行处打断点 break -偏移量 在当前暂停位置往前几行处处打断点 break *地址 在指定地址处打断点 断点可以附加条件： 格式：break 断点 if 条件\n举例，如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 gdb ./gdb_test.exe ...... (gdb) b 17 if i==5 Breakpoint 1 at 0x11ba: file main.c, line 17. (gdb) info b Num Type Disp Enb Address What 1 breakpoint keep y 0x00000000000011ba in happy at main.c:17 stop only if i==5 (gdb) run Starting program: /home/yuangod/project/c/gdb_test/gdb_test.exe Breakpoint 1, happy () at main.c:17 17\tprintf(\u0026#34;happyi %d\\n\u0026#34;, i); (gdb) info b Num Type Disp Enb Address What 1 breakpoint keep y 0x00005555555551ba in happy at main.c:17 stop only if i==5 breakpoint already hit 1 time hbreak tbreak thbreak 其它断点 硬件断点(hbreak)，适用于ROM 空间等无法修改的内存区域中的程序。在有些架构中无法使用。\n临时断点(tbreak)和临时硬件断点(thbreak)，与断点(硬件断点)相同，都会在运行到该处时暂停，\n不同之处就是临时断点(临时硬件断点)会在此时被删除，所以在只需要停止一次时用起来很方便。\n三者的语法与break一样\nclear cl 清除断点 break 的反命令，\n格式与break类似，不过 break 会创建断点，而 clear 会删除断点。\nenable en / disable disa dis 启用/禁用断点 对于 enable：\n格式 作用 enable 启用所有断点 enable 断点编号 启用指定的断点 对于 disable：\n格式 作用 disable 禁用所有断点 disable 断点编号 禁用指定的断点 conditon 断点条件的添加(替换)与删除 格式 作用 condition 断点编号 删除断点的条件 condition 断点编号 条件 添加(替换)断点的条件(如果没有条件就添加，有条件就替换) 举例，如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 (gdb) info b Num Type Disp Enb Address What 1 breakpoint keep y 0x00005555555551ba in happy at main.c:17 stop only if i==5 breakpoint already hit 1 time (gdb) condition 1 Breakpoint 1 now unconditional. (gdb) info b Num Type Disp Enb Address What 1 breakpoint keep y 0x00005555555551ba in happy at main.c:17 breakpoint already hit 1 time (gdb) condition 1 i==5 (gdb) info b Num Type Disp Enb Address What 1 breakpoint keep y 0x00005555555551ba in happy at main.c:17 stop only if i==5 breakpoint already hit 1 time (gdb) condition 1 i!=6 (gdb) info b Num Type Disp Enb Address What 1 breakpoint keep y 0x00005555555551ba in happy at main.c:17 stop only if i!=6 breakpoint already hit 1 time (gdb) condition 1 i!=6 \u0026amp;\u0026amp; i==5 (gdb) info b Num Type Disp Enb Address What 1 breakpoint keep y 0x00005555555551ba in happy at main.c:17 stop only if i!=6 \u0026amp;\u0026amp; i==5 breakpoint already hit 1 time run r 运行 格式：run [参数...]\n(重头开始)运行，直到结束或者遇到断点。\n添加的参数会传递给程序(而非run本身有参数)。\nstart 开始 格式：start [参数...]\n与 run 类似，但是运行到 main 函数停止，\n等价于在 main 函数处打上断点( break main )，然后执行 run。\nbacktrace bt where 显示栈帧 格式 作用 backtrace 显示所有栈帧 backtrace full 显示所有栈帧(及其局部变量) backtrace N 显示开头(栈顶) N 个栈帧 backtrace full N 显示开头(栈顶) N 个栈帧(及其局部变量) backtrace -N 显示最后(栈底) N 个栈帧 backtrace full -N 显示最后(栈底) N 个栈帧(及其局部变量) print p 显示变量 格式①：print 变量\n举例 作用 print argv 查看参数字符串组的地址 print *argv 查看参数字符串组的首元素(程序名) print argv[0] 查看参数字符串组的首元素(程序名) print argv[1] 查看参数字符串组的第二个元素(第一个参数) 格式②: print/格式 $寄存器\n格式 作用 x 显示为十六进制数 d 显示为十进制数 u 显示为无符号十进制数 o 显示八进制数 t 显示为二进制数，t的由来是two a 地址 c 显示为字符(ASCII) f 浮点小数 s 显示为字符串 i 显示为机器语言(仅在显示内存的x命令中可用) 如下举例:\n1 2 3 4 (gdb) p $1 $4 = 5 (gdb) p/t $1 $5 = 101 x 显示内存 x 源自 eXamining。\n格式：x/NFU 地址\nN：重复的次数\nF：同print p 显示变量中提到的格式。\nU：表示单位( b、h、w、g ， 分别为 字节、半字(2字节)、字(四字接)、双字(8字节) )\n如下举例:\n1 2 3 # 读取pc当前指向的汇编指令 (gdb) x/i $pc =\u0026gt; 0x555555555171 \u0026lt;deepdark+8\u0026gt;:\tlea 0xe8c(%rip),%rax # 0x555555556004 disassemble disas 反汇编 格式 作用 disassemble 反汇编当前整个函数 disassemble 程序计数器 从pc开始，反汇编其所在函数的末尾 disassemble 开始地址,结束地址 反汇编从开始地址到结束地址之前的部分(注意逗号要加上) next n 单步(不进入函数内部) 格式 作用 next (源代码级别)单步(不进入函数内部)执行 1 行 next N (源代码级别)单步(不进入函数内部)执行 n 行 nexti (机械指令、汇编级别)单步(不进入函数内部)执行 1 行 nexti N (机械指令、汇编级别)单步(不进入函数内部)执行 n 行 step s 单步(进入函数内部) 格式 作用 step (源代码级别)单步(进入函数内部)执行 1 行 step N (源代码级别)单步(进入函数内部)执行 n 行 stepi (机械指令、汇编级别)单步(进入函数内部)执行 1 行 stepi N (机械指令、汇编级别)单步(进入函数内部)执行 n 行 ignore 忽略断点、监视点、捕获点 格式：ignore 断点编号 N\n忽略指定编号的忽略断点、监视点、捕获点接下来会忽略 N 次命中。\n效果类似与 continue N ，但有所不同。\ncontinue c fg 继续运行 格式 作用 continue 继续运行，直到结束或者遇到断点 continue N 同 continue，不过当前停止处的断点接下来会忽略 N-1 次命中(即使使用run等命令重启程序也会生效) continue N 效果类似 ignore，但由所不同。 如果没有停在断点处，并执行格式 continue N，那么会自动退化为 continue。 continue 1 效果上等同于 continue 。 举例，如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 ...... Breakpoint 2, happy () at main.c:16 16\tint i = 5; (gdb) c 3 Will ignore next 2 crossings of breakpoint 2. Continuing. happyi 5 Breakpoint 3, unhappy () at main.c:10 10\tprintf(\u0026#34;unhappy\\n\u0026#34;); (gdb) info b Num Type Disp Enb Address What 2 breakpoint keep y 0x00005555555551b3 in happy at main.c:16 breakpoint already hit 1 time ignore next 2 hits 3 breakpoint keep y 0x000055555555518b in unhappy at main.c:10 breakpoint already hit 1 time ...... finish fin 执行完当前函数 格式 finish\n执行后会直接运行到当前函数结束(退出当前函数)。\nuntil u 运行到某一位置 格式 作用 until 运行到源代码中下一行(比当前行号大的行)。如果位于循环体的最后一行，会执行完循环体，然后停在下一行，如果在函数体的最后一行，那么会退出函数。 until 位置 运行，直到指定的位置(可以是行号、函数、地址等等) 会触发断点 格式 until 位置 ，位置必须在当前栈帧内，如果不在，大概率会运行到下个断点或者程序结束处。 watch awatch rwatch 监视点 大型软件或大量使用指针的程序中，很难弄清变量在什么地方被改变。\n要想找到变量在何处被改变，可以使用 watch 相关的命令(监视点，watchpoint)\n格式 作用 watch \u0026lt;表达式\u0026gt; 监视\u0026lt;表达式\u0026gt;改变(写入) awatch \u0026lt;表达式\u0026gt; 监视\u0026lt;表达式\u0026gt;被访问(读取)、改变(写入) rwatch \u0026lt;表达式\u0026gt; 监视\u0026lt;表达式\u0026gt;被访问(读取) \u0026lt;表达式\u0026gt;一般为常量或者变量等等。\n使用监视点可能会降低运行速度。\n举例，如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 (gdb) rwatch i Hardware read watchpoint 6: i (gdb) c Continuing. Hardware read watchpoint 6: i Value = 5 0x00005555555551bd in happy () at main.c:17 17\tprintf(\u0026#34;happyi %d\\n\u0026#34;, i); (gdb) info break Num Type Disp Enb Address What 2 breakpoint keep y 0x0000555555555171 in deepdark at main.c:5 4 breakpoint keep y 0x00005555555551b3 in happy at main.c:16 breakpoint already hit 1 time 6 read watchpoint keep y i breakpoint already hit 1 time delete d del 删除断点和监视点 格式：delete \u0026lt;编号\u0026gt;\n删除\u0026lt;编号\u0026gt;所指示的断点或监视点。\nset 设置值 格式 作用 set variable \u0026lt;变量\u0026gt;=\u0026lt;表达式\u0026gt; 改变变量的值 set $\u0026lt;便利变量名\u0026gt;=\u0026lt;表达式\u0026gt; 设置 gdb 内的\u0026quot;便利变量\u0026quot;(类似于宏) set history [功能] 开启命令历史的功能 格式 set variable \u0026lt;变量\u0026gt;=\u0026lt;表达式\u0026gt; 举例，如下：\n1 2 3 4 5 (gdb) p i $14 = 5 (gdb) set variable i = 2026 (gdb) p i $15 = 2026 格式 set $\u0026lt;便利变量名\u0026gt;=\u0026lt;表达式\u0026gt; 举例，如下：\n1 2 3 4 5 6 7 8 (gdb) set $my_var=10 (gdb) p $my_var $1 = 10 (gdb) set $log10 = (double (*)(double)) log10 (gdb) p $log10(10) $4 = 1 (gdb) p $log10($my_var) $5 = 1 generate-core-file gcore 生成Core dump文件 用于在调试的过程中生成 Core dump 文件，制作进程的\u0026quot;快照\u0026quot;。\n如下：\n1 2 3 4 5 6 7 8 9 10 11 12 (gdb) generate-core-file warning: Memory read failed for corefile section, 4096 bytes at 0xffffffffff600000. Saved corefile core.638095 (gdb) q A debugging session is active. Inferior 1 [process 638095] will be killed. Quit anyway? (y or n) y ~$ gdb -c core.638095 ./gdb_test.exe ...... 值得注意的是 gcore 也是一个GNU工具( 详情见 gcore(1) )，可以直接在 shell 中使用，如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 # gcore [-a] [-o filename] pid[s] ~$ ps aux | grep vim bigshot 633690 0.3 0.0 28244 13948 pts/1 Sl+ 18:30 0:00 vim hello bigshot 633706 0.0 0.0 9304 2460 pts/2 S+ 18:30 0:00 grep --color=auto vim ~$ gcore -o core_vim 633690 [New LWP 633691] [Thread debugging using libthread_db enabled] Using host libthread_db library \u0026#34;/lib/x86_64-linux-gnu/libthread_db.so.1\u0026#34;. 0x000072ecb0126d07 in select () from /lib/x86_64-linux-gnu/libc.so.6 warning: Memory read failed for corefile section, 4096 bytes at 0xffffffffff600000. Saved corefile core_vim.633690 ~$ ls core_vim.633690 core_vim.633690 # 之后边可以执行下面的命令复原保存时的 vim 进程环境 ~$ gdb -c core_vim.633690 vim ...... attach detach 调试(附加到)和脱离已启动进程 要调试守护进程(daemon process)等已经启动的进程，或是调试陷入死循环而无法返回控制台的进程时，可以使用 attach 命令。\n格式：attach \u0026lt;pid\u0026gt;\n而脱离直接输入 detach 即可。\nattach 之后就能使用普通的 gdb 命令，因此可以通过 print 命令显示变量，也可以设置断点。\n此外，恢复程序运行一般可以使用 continue命令(简写为c)。\n确认了行为之后，需要在 gdb 和 进程 分离时使用 detach 命令。这样调试中的进程就被从 gdb 的控制下释放出来。进程在被 detach 后会继续运行。\n举例，如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 ~$ sleep 10000 \u0026amp; [1] 647246 ~$ gdb ...... (gdb) attach 647246 ...... # 这里通过 attach 和 bt 直接看到 sleep 程序的栈帧 (gdb) bt #0 0x000078618caeca7a in __GI___clock_nanosleep (clock_id=clock_id@entry=0, flags=flags@entry=0, req=0x7ffcb34c71e0, rem=0x7ffcb34c71d0) at ../sysdeps/unix/sysv/linux/clock_nanosleep.c:78 #1 0x000078618caf9a27 in __GI___nanosleep (req=\u0026lt;optimized out\u0026gt;, rem=\u0026lt;optimized out\u0026gt;) at ../sysdeps/unix/sysv/linux/nanosleep.c:25 #2 0x000059a509e9da7f in ?? () #3 0x000078618ca2a1ca in __libc_start_call_main (main=main@entry=0x59a509e9d5d0, argc=argc@entry=2, argv=argv@entry=0x7ffcb34c7358) at ../sysdeps/nptl/libc_start_call_main.h:58 #4 0x000078618ca2a28b in __libc_start_main_impl (main=0x59a509e9d5d0, argc=2, argv=0x7ffcb34c7358, init=\u0026lt;optimized out\u0026gt;, fini=\u0026lt;optimized out\u0026gt;, rtld_fini=\u0026lt;optimized out\u0026gt;, stack_end=0x7ffcb34c7348) --Type \u0026lt;RET\u0026gt; for more, q to quit, c to continue without paging-- at ../csu/libc-start.c:360 #5 0x000059a509e9dba5 in ?? () # 查看进程信息 (gdb) info proc process 647246 cmdline = \u0026#39;sleep 10000\u0026#39; cwd = \u0026#39;/home/yuangod/project/c/gdb_test\u0026#39; exe = \u0026#39;/usr/bin/sleep\u0026#39; # 脱离 (gdb) detach Detaching from program: /usr/bin/sleep, process 647246 [Inferior 1 (process 647246) detached] (gdb) info proc No current process: you must name one. commands 断点命令 格式：\n1 2 3 4 commands 断点编号 命令 ... end 举例，如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 ...... Temporary breakpoint 1, main () at main.c:23 23\tprintf(\u0026#34;this is a gbd test program\\n\u0026#34;); (gdb) b 17 Breakpoint 2 at 0x5555555551ba: file main.c, line 17. (gdb) commands 2 Type commands for breakpoint(s) 2, one per line. End with a line saying just \u0026#34;end\u0026#34;. \u0026gt;silent \u0026gt;p i \u0026gt;end (gdb) c Continuing. this is a gbd test program $1 = 5 # silent命令的作用是不显示断点处暂停的消息。 ...... list l 显示函数或行 格式 作用 list 列出上次列出内容之后的十行代码，或者围绕上次列出位置（取决于上下文）。 list + 列出上一次列出的十行代码之后的十行代码。 list - 列出上一次列出的十行代码之前的十行代码。 list . 列出当前执行点（即程序暂停的位置）周围十行的代码。 list 行号 列出该行周围十行的代码。 list 开始行号,结束行号 列出从开始行号到结束行号范围内的代码。 位置还可以为地址等，因为过多，这里省略。 特别地， list *$pc 可以显示当前行周围的代码(与 list . 不同，这显示当前的地址与行号)。 help h 帮助文档 格式：help 命令 举例，如下：\n1 2 3 4 5 ...... (gdb) help help help, h Print list of commands. ...... show 显示数据 格式 作用 show value print 命令显示历史的最新十个记录 show history [功能] 显示命令历史功能的开关与说明，与 set history [功能] 配合使用 define 命令定义 / document 命令说明 define 可以用于自定义命令(类似函数)，格式如下：\n1 2 3 4 define 命令名 命令 ... end document 可以用于给自定义命令添加说明，格式如下：\n1 2 3 document 命令名 说明 end 举例，如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 (gdb) define li Type commands for definition of \u0026#34;li\u0026#34;. End with a line saying just \u0026#34;end\u0026#34;. \u0026gt;x/10i $pc \u0026gt;end (gdb) document li Type documentation for \u0026#34;li\u0026#34;. End with a line saying just \u0026#34;end\u0026#34;. \u0026gt;list machine instruction \u0026gt;end (gdb) li =\u0026gt; 0x5555555551e8 \u0026lt;main+8\u0026gt;:\tlea 0xe31(%rip),%rax # 0x555555556020 0x5555555551ef \u0026lt;main+15\u0026gt;:\tmov %rax,%rdi 0x5555555551f2 \u0026lt;main+18\u0026gt;:\tcall 0x555555555060 \u0026lt;puts@plt\u0026gt; 0x5555555551f7 \u0026lt;main+23\u0026gt;:\tmov $0x0,%eax 0x5555555551fc \u0026lt;main+28\u0026gt;:\tcall 0x5555555551a7 \u0026lt;happy\u0026gt; 0x555555555201 \u0026lt;main+33\u0026gt;:\tmov $0x0,%eax 0x555555555206 \u0026lt;main+38\u0026gt;:\tpop %rbp 0x555555555207 \u0026lt;main+39\u0026gt;:\tret 0x555555555208 \u0026lt;_fini\u0026gt;:\tendbr64 0x55555555520c \u0026lt;_fini+4\u0026gt;:\tsub $0x8,%rsp (gdb) help li list machine instruction source 引入初始化文件 格式：source 文件名\n除了初始化文件，这种方式也能引入命令进行设置。\n参考文章 Linux 核心转储（Core Dump）位置详解：配置、实践与故障排除\nArch Linux 中文维基\nLinux 配置 coredump Debug Hacks中文版\n","date":"2026-01-11T18:52:26+08:00","permalink":"https://DSJZS.github.io/p/linux%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%951%E5%A6%82%E4%BD%95%E6%84%89%E5%BF%AB%E7%9A%84debug%E7%A8%8B%E5%BA%8F/","title":"Linux开发学习记录(1)：如何愉快(?)的Debug程序"},{"content":"简介 第二篇Wi-Fi学习记录，本篇介绍了如何利用常见的网络工具配置无线网络，连接上网络进行🏄活动。\n观前需知 ① 本文演示设备安装的系统为 Ubuntu Server，具体如下。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 ~$ cat /etc/os-release PRETTY_NAME=\u0026#34;Ubuntu 24.04.3 LTS\u0026#34; NAME=\u0026#34;Ubuntu\u0026#34; VERSION_ID=\u0026#34;24.04\u0026#34; VERSION=\u0026#34;24.04.3 LTS (Noble Numbat)\u0026#34; VERSION_CODENAME=noble ID=ubuntu ID_LIKE=debian HOME_URL=\u0026#34;https://www.ubuntu.com/\u0026#34; SUPPORT_URL=\u0026#34;https://help.ubuntu.com/\u0026#34; BUG_REPORT_URL=\u0026#34;https://bugs.launchpad.net/ubuntu/\u0026#34; PRIVACY_POLICY_URL=\u0026#34;https://www.ubuntu.com/legal/terms-and-policies/privacy-policy\u0026#34; UBUNTU_CODENAME=noble LOGO=ubuntu-logo ② 代码块中的 ...... 表示省略，避免显示无用信息。\n③ 代码快中的 ~$ 为shell命令行提示符，表示后面的是shell命令\n④ 可以用 man 命令或者访问 Arch Linux 中文维基 等方式查询感到疑惑的内容。\n废键盘的操作方式💥⌨ 所谓的“废键盘”指的是不利用任何管理工具，手动执行每一步配置操作。\n添加无线网卡接口并打开 ① 首先可以执行 iw list 查看网卡的可用接口组合，如下：\n1 2 3 4 5 6 7 8 9 ~$ iw list Wiphy phy0 ...... valid interface combinations: * #{ managed } \u0026lt;= 2, #{ P2P-device } \u0026lt;= 1, #{ P2P-client, P2P-GO } \u0026lt;= 1, total \u0026lt;= 3, #channels \u0026lt;= 2 * #{ managed } \u0026lt;= 1, #{ AP } \u0026lt;= 1, #{ P2P-client } \u0026lt;= 1, #{ P2P-device } \u0026lt;= 1, total \u0026lt;= 4, #channels \u0026lt;= 1 ...... 可以看到我的网卡phy0有两个组合，其中组合一支持同时运行两个managed接口（managed模式可以理解为STA模式，与AP模式对应），这正好方便我们演示如何配置。\n② 执行 sudo iw phy phy0 interface add wlan1 type managed 来创建一个 managed 模式的新接口。我们可以执行 iw dev来查看，如下：\n1 2 3 4 5 6 7 8 9 10 ~$ iw dev phy#0 Interface wlan1 ifindex 4 wdev 0x3 addr 2e:cf:67:8f:fb:3b type managed channel 36 (5180 MHz), width: 80 MHz, center1: 5210 MHz txpower 31.00 dBm ...... 可以看到新接口被成功的创建了。\n③ 执行 sudo ip link set wlan1 up 打开（所谓的\u0026quot;上行\u0026quot;）新建的接口\n让网卡接口连接到接入点(AP) 网卡创建好了之后，就要开始链路层的连接了，对于无线网络来说，最常见的就是STA连接AP了。\n① 创建AP\n这一步很容易完成，一般来说使用手机开启热点即可做到。可以使用 iw dev wlan1 scan 来测试接口是否能扫描到热点，如下：\n1 2 3 # 这里我创建了一个 SSID 为 HELLOWORLD 的热点 ~$ iw dev wlan1 scan | grep \u0026#39;HELLOWORLD\u0026#39; SSID: HELLOWORLD 这里我让刚才创建的wlan1接口进行扫描，看它是否能找到我刚才创建的热点。\n② 获取PSK，获取配置文件\n想必大家的热点都设置了密码对吧？为了能够成功连接，我们需要使用密码进行验证操作。\n本文创建的热点采用WPA2，因为树莓派自带的网卡似乎对WPA3支持的不太好\n我们可以使用 wpa_passphrase 来获取PSK，并重定向到配置文件，如下：\n1 2 3 4 5 6 7 8 9 10 # 这里可以直接给出 ssid 与 passphrase # 也可以只给出 ssid，然后在标准输入流中写入 passphrase # 后者被认为更安全 ~$ wpa_passphrase HELLOWORLD THISISMYPASSWORD \u0026gt; hello_world.config ~$ cat hello_world.config network={ ssid=\u0026#34;HELLOWORLD\u0026#34; #psk=\u0026#34;THISISMYPASSWORD\u0026#34; psk=30de7b35dd21ef152bf48de9731c46f516daed2079b8a2011609d160d1f4e157 } ③ 利用配置文件连接AP wpa_supplicant 是一个 WPA Supplicant(接入客户端) 组件的实现。\n这里要使用 wpa_supplicant 工具进行认证与连接。如下：\n1 2 3 4 # -B , 表示后台运行程序，如果想要前台观察Log等信息，可以不加此选项 # -i , 指定无线网络接口，这里为前几步创建的接口 wlan1 # -c , 指定配置文件，这里直接使用刚才利用 wpa_passphrase 创建的配置文件 ~$ sudo wpa_supplicant -B -i wlan1 -c hello_world.config 此时如果参数正确，网络接口就会顺利的连接上AP，链路层的连接就完毕了。\n不过此时我们查询新接口的的一些信息，便会发现一些严重的问题，如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 ~$ ip addr show dev wlan1 4: wlan1: \u0026lt;BROADCAST,MULTICAST,UP,LOWER_UP\u0026gt; mtu 1500 qdisc pfifo_fast state UP group default qlen 1000 link/ether 2e:cf:67:8f:fb:3b brd ff:ff:ff:ff:ff:ff inet6 fe80::2ccf:67ff:fe8f:fb3b/64 scope link valid_lft forever preferred_lft forever # 新的接口似乎没有IPv4地址 ~$ resolvectl status wlan1 Link 4 (wlan1) Current Scopes: none Protocols: -DefaultRoute -LLMNR -mDNS -DNSOverTLS DNSSEC=no/unsupported # 似乎也没有配置任何 DNS 服务器 # 如果强行使用新接口，会产生警告，并且无法正常访问 ~$ ping -I wlan1 baidu.com ping: Warning: source address might be selected on device other than: wlan1 原来链路层的连接完毕了不意味着新接口就能成功上网了，此时还需要DHCP服务（本文不演示静态配置）。\n获取DHCP服务 我们可以通过**DHCP客户端工具(dhcpcd)**自动地获取IPv4地址与DNS服务器，如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 ~$ sudo dhcpcd -b wlan1 dhcpcd-10.0.6 starting ~$ ip address show dev wlan1 4: wlan1: \u0026lt;BROADCAST,MULTICAST,UP,LOWER_UP\u0026gt; mtu 1500 qdisc pfifo_fast state UP group default qlen 1000 link/ether 2e:cf:67:8f:fb:3b brd ff:ff:ff:ff:ff:ff inet 192.168.10.41/24 brd 192.168.10.255 scope global dynamic noprefixroute wlan1 valid_lft 3589sec preferred_lft 3139sec inet6 fe80::2ccf:67ff:fe8f:fb3b/64 scope link valid_lft forever preferred_lft forever ~$ resolvectl status wlan1 Link 4 (wlan1) Current Scopes: DNS Protocols: +DefaultRoute -LLMNR -mDNS -DNSOverTLS DNSSEC=no/unsupported DNS Servers: 192.168.10.237 # 现在可以正常的访问网络了 ~$ ping -c 1 -I wlan1 baidu.com PING baidu.com (110.242.74.102) from 192.168.10.41 wlan1: 56(84) bytes of data. 64 bytes from 110.242.74.102: icmp_seq=1 ttl=48 time=74.9 ms --- baidu.com ping statistics --- 1 packets transmitted, 1 received, 0% packet loss, time 0ms rtt min/avg/max/mdev = 74.912/74.912/74.912/0.000 ms 一些自动配置工具 可以看到手动输入一个个指令十分的麻烦，我们可以使用一些工具来自动配置。\nsystemd-networkd 一般安装在Ubuntu Server等纯命令行环境下(桌面环境下一般是 NetworkManager，本文不涉及)。\nsystemd-networkd 是 systemd 的配套组件，配置完后可以自动检测链路层是否建立连接，\n检测到连接其会自动的配置DHCP等功能，要使用它必须在一些特定的文件夹下编写 systemd.network 单元,\n这里在 /etc/systemd/network/ 目录下新建 10-wlan1.network 单元文件。\n1 2 3 4 5 6 7 8 9 10 11 12 13 # 单元文件名格式为: 数字-文件名.network # 数字越小优先级越高，文件后缀应该为 network ~$ cat /etc/systemd/network/10-wlan1.network [Match] Name=wlan1 [Network] DHCP=ipv4 LinkLocalAddressing=ipv6 [DHCP] RouteMetric=600 UseMTU=true 之后重启设备或者执行 sudo systemctl restart systemd-networkd 来刷新服务。\n如果没有 DHCP服务 请等待一会儿，新配置一般比较慢。\nsystemd 既然提到了 systemd-networkd ，那么 systemd 也不能落下。\nsystemd 是当今最流行的初始化与进程管理系统实现，ubuntu、debian等系统都默认使用它。\n我们将使用 systemd.service 单元，实现开机自动创建新的接口，然后自动连接对应的AP。\n这里将在 /etc/systemd/system/ 目录下创建两个单元，分别用于打开新接口和使用wpa_supplicant进行连接。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 ~$ cat /etc/systemd/system/wlan-sta.service [Unit] Description=Create some managed(sta) interface [Service] Type=oneshot ExecStart=/usr/sbin/iw phy phy0 interface add wlan1 type managed ExecStartPost=/usr/sbin/ip link set dev wlan1 up ExecStop=/usr/sbin/ip link set wlan1 down ExecStop=/usr/sbin/iw dev wlan1 del RemainAfterExit=yes [Install] WantedBy=multi-user.target ~$ cat /etc/systemd/system/wpa-wlan1.service [Unit] Description=WPA supplicant for wlan1 Requires=wlan-sta.service After=wlan-sta.service [Service] Type=simple # 这里 /path/to/hello_world.config 修改为你设置上对应的路径 # 这里为了演示，模糊化了路径 ExecStart=/sbin/wpa_supplicant -c /path/to/hello_world.config -i wlan1 ExecReload=/sbin/wpa_cli -i wlan1 reconfigure [Install] WantedBy=multi-user.target 然后设置它们开机自启动。\n1 2 sudo systemctl enable wlan-sta.service sudo systemctl enable wpa-wlan1.service 之后我们每次启动电脑，便会自动查创建wlan1接口，并按照hello_world.config连接AP。\n如果你同时使用了 systemd-networkd ，链路层连接成功后会自动获取DHCP等服务。\n待更新 等待更新中\u0026hellip;\u0026hellip;\n","date":"2026-01-07T22:00:03+08:00","permalink":"https://DSJZS.github.io/p/wi-fi%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%952linux%E6%97%A0%E7%BA%BF%E7%BD%91%E7%BB%9Csta%E6%A8%A1%E5%BC%8F%E9%85%8D%E7%BD%AE/","title":"Wi Fi网络学习记录(2)：Linux无线网络STA模式配置"},{"content":"简介 第一篇Wi-Fi网络学习记录，简单的设计一个ARP协议抓包实验，并对结果进行分析。\n适合了解了ARP协议的人观看🤓。\nARP协议简介 功能介绍 ARP的中文名称为地址解析协议。对于TCP/IP网络，ARP协议提供了一种建立某个主机接口IPv4地址与其MAC地址之间映射的方法（换句话说，可以通过某个主机的IPv4地址找到它的MAC地址）。\n之所以强调IPv4地址，是因为ARP仅用于IPv4，IPv6使用邻居发现协议。\n与之相反的协议为RARP，不过其几乎已经不再被使用。\nARP帧格式 本文的实验是直接监听网卡接口，收到的是Ethernet II帧，故这里给出对应的格式。\nARP帧字段解释：\n硬件类型：硬件地址(MAC地址)的类型。对于以太网，这里为1。 协议类型：映射的协议协议地址类型。对于IPv4地址，此字段为0x0800。 硬件大小：硬件地址的字节数。对于MAC地址，应该为6。 协议大小：协议地址的字节数。对于IPv4地址，应该为4. Op：ARP请求(1)、ARP应答(2)、RARP请求(3)、RARP应答(4)。 地址字段：用于存放发送方与接收方的硬件地址与协议地址。 ARP缓存表 这个表格维护了每个接口从IP地址到MAC地址的最新映射(每个IPv4地址对应的MAC地址)。\n每个条目由ARP协议动态学习或者手工输入得到。\n在 Windows/Linux 中，可以通过 arp -a 指令查看。\nWireshark抓包流程 准备网络环境 创建一个局域网，并准备包括电脑网卡接口在内的两个无线网络接口(平板、手机或者另一个电脑网卡接口等等)。确保它们都能连接上局域网。\n检查ARP缓存表 使用 arp -a 指令查询当前设备的 ARP缓存表，确保另一台设备不在这个表中。 如下所示，除了网关以外没有任何接口的记录。\n1 2 ❯ arp -a \u0026gt;_gateway (192.168.102.158) 位于 66:ce:bd:27:59:a9 [ether] 在 wlo1 如果有了另一台设备的记录(比如重复实验等情况)，可以用 sudo arp -d \u0026lt;IPv4地址\u0026gt;进行删除。\n查询另一台设备的IPv4地址 这个操作可以通过设备的设置软件或者AP设备(比如你的路由器)查询。\n本文中另一台设备的IPv4地址为 192.168.102.112，下文不在复述。\n打开Wireshark并抓包 打开Wireshark，并在过滤器中输入arp。 打开虚拟终端软件，输入 ping 192.168.102.112\n(这里的IP地址由前面的查询步骤得到). 最终应该会得到1对或者2对ARP帧。如上图所示(可以放大观看)。\nWireshark抓包内容解析 上一个步骤一共得到了四个ARP帧，这里分别做解释。\n第一个ARP帧 当执行ping 192.168.102.112时。电脑的ARP缓存表中并没有对应的条目，\n因此为了得到 192.168.102.112 与MAC地址的映射关系，协议栈软件底层自动发送了一个ARP请求帧。 Ethernet II头部中：\n目标地址：全1，表示广播，表示发往同一局域网中的所有接口。 源地址：为电脑网卡接口的MAC地址。 类型：为0x0806，表明这是一个ARP协议帧，载荷交由ARP协议软件处理。 ARP协议内容： 前四个字段如ARP帧格式中介绍的一样。 Op：为1，表示这个帧为ARP请求帧，希望得到目标接口的应答。 后面的地址字段也和ARP帧格式中介绍的一样。\n值得注意的是目的硬件地址为全0，因为当前还不知道。 第二个ARP帧 IPv4地址为 192.168.102.112 的接口收到了电脑网卡接口广播的ARP请求，单播进行应答。\nEthernet II头部中的：\n目标地址：为ARP请求发送方的MAC地址。 源地址：目标接口的MAC地址。 类型：为0x0806，表明这是一个ARP协议帧，载荷交由ARP协议软件处理。 ARP协议内容： 前四个字段如ARP帧格式中介绍的一样。 Op：为2，表示这个帧为ARP应答帧，是对ARP请求的应答。 后面的地址字段也和ARP帧格式中介绍的一样。\n电脑网卡接口收到ARP应答帧后会将其解析并作为一个动态条目加入ARP缓存表 第三个和第四个ARP帧 一般而言，目标设备收到ARP请求时，除了发送ARP应答，还会在ARP缓存表中添加有关发送方的映射条目。这是一个很常见的优化举措，但这里目标设备并没有这么做。\n当它被电脑 ping 时，它为了回复同样也需要知晓电脑网卡接口的IPv4地址与MAC地址的映射关系，但是它发送ARP应答的时候并没有记录，因此它这里也需要往电脑发送ARP请求，等待电脑网卡接口的ARP应答，这就是第三个和第四个ARP帧的由来，可以参考前两个ARP帧示例。\n结语 ARP协议算是比较简单的协议了，Wireshark抓包还是比较容易的，快去亲手试试吧🫵。\n","date":"2026-01-05T18:16:41+08:00","permalink":"https://DSJZS.github.io/p/wi-fi%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%951%E6%8A%93%E5%8C%85arp%E5%8D%8F%E8%AE%AE/","title":"Wi-Fi网络学习记录(1)：抓包ARP协议"},{"content":"第一次元旦总结 开场白 这个网页也是迎来了它的第一个元旦，可喜可贺(虽然还没几天)，回想这一年也是经历了很多很多的事情，很难一一说清，如今就挑几件比较重要的事情来说吧\n2025年的上半年 上半年最印象深刻的就是电赛了，当时选的是E题，也就是激光瞄准，四天三夜那真是累坏了，一个人干电控的活今天下来那真的是一点都没有闭眼啊，每天干活干20个小时，差点挂掉了😵，虽然最后就完成了三个基础题，不过也算有始有终吧，对平时的学习有一个交待了，也是把自己当时能干的全干了。\n2025年的下半年 下半年就比较魔幻了，毕竟不打比赛了，于是到处扩展理论知识一直在各个领域犹豫不决，不知道以后干啥，最后也是在机器人、车控、物联网的等领域转来转去的😵‍💫。到现在也是终于下定决心以后干什么了，虽然不知道以后具体怎么样，但总算有一个固定的方向了吧。\n总结与展望 如今虽说也很迷茫，但是有方向了，希望下次总结的时候有更大的进展吧!💪\n结语 本来打算2025年的最后一天写完然后一到元旦就发的，然而各种各样的事情耽误了(绝对不是摸🐟)，延迟了几天才发\n","date":"2025-12-31T23:43:52+08:00","permalink":"https://DSJZS.github.io/p/%E7%BD%91%E7%AB%99%E8%BF%8E%E6%9D%A5%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%85%83%E6%97%A6/","title":"网站迎来的第一个元旦🥳"},{"content":"事情的缘由 学习了ESP32的HTTP服务器示例之后，感觉这玩意挺好玩的，于是没事找事地看了下前端的课程。\n对前端基础工具的理解 作为一个初学者(学习没一两天)，而且不打算以前端为主要工作方向的在校生，对于这方面肯定不专业，只略微的了解过HTML、CSS 和 JavaScript，以下为我当前的，个人的看法。😖\nHTML 首先 HTML 我觉得是必须学的(至少要了解)，因为这玩意是网页的“骨架”，很大程度上决定了网页的布局，各种内容(比如文本，图片啥的)应该怎么摆。靠AI生成也行，但是很难精准作出自己想要的布局，要描写大量的文本来实现，还是得了解 h、p、a、form、input 等基础的标签还有对应的属性，方便进行微调。🤓\nCSS CSS 主要用于装饰，大部分内容可以靠AI完成，本人没有什么艺术细胞，自己写肯定不如AI写的顺眼，当然至少需要了解这玩意是啥，能干什么以及不能干什么，这样给AI的提示词啥的更准确，风格更接近自己想要的样子。😋\nJavaScript JavaScript 感觉必须得了解，因为它决定了网页背后的“逻辑”，如何与用户还有后端交互，个人觉得可以靠AI辅助，但是必须得懂，如果不懂可能出现比较大的问题(就像某个人完全不懂命令行，让AI生成一个涉及rm命令的操作一样，对了就对了，错了就💥了)，这种涉及执行逻辑的内容我一般不会让AI全部完成。🤔\n结语 前端感觉入门容易，入门之后怎么样就不懂了，你是怎么看得了?🫵\n","date":"2025-12-28T18:25:03+08:00","permalink":"https://DSJZS.github.io/p/%E9%9D%9E%E5%89%8D%E7%AB%AF%E5%B7%A5%E4%BD%9C%E8%80%85%E5%AF%B9%E4%BA%8Ehtmlcssjavascript%E7%9A%84%E5%90%90%E6%A7%BD/","title":"非前端工作者对于HTML、CSS、JavaScript的吐槽"},{"content":"事情的缘由 今天完善网站的音乐播放器，发现给播放器添加歌曲需要歌曲的封面图片、音乐文件、歌词文件等等，而要从网易云等网站中下载这些文件太麻烦了!!!\n本着能偷懒就偷懒的原则，果断去网上寻找工具，找了没一会儿还真找到一个满足我所有要求的开源项目——163MusicLyrics\n软件的下载与安装 Github仓库地址: https://github.com/jitwxs/163MusicLyrics.git\n参考仓库 官方Wiki的Downloads部分与Quick Start部分\n具体的使用方法 参考仓库 官方Wiki的Use Guide部分\n结语 感谢贡献163MusicLyrics项目的开源开发者们!!!\n","date":"2025-12-25T22:49:59+08:00","permalink":"https://DSJZS.github.io/p/%E6%8E%A8%E8%8D%90%E4%B8%80%E4%B8%AA%E5%BC%80%E6%BA%90%E5%B7%A5%E5%85%B7163musiclyrics/","title":"推荐一个开源工具👉163MusicLyrics👈"},{"content":"事情的缘由 最近学习各种协议、组件等等，发现了很多大佬的博客，想着昨天休息，也没啥活动，于是心血来潮准备搞个个人博客网站。一开始照着B站上的教程搭建的无比顺利，搭建完之后虽然页面啥也没有，但总算能发布博客了。今天没事找事看着博客的画风特别丑陋，而且按键也不符合我的习惯，于是就开始折腾Hugo框架设置。然后我的🧠就💥了。\n个人的吐槽 鉴于本人的专业，完全没学过网站的设计，CCS 还有 HTML 啥的那是完全不懂啊，看着跟天书一样，在经历了4~5个小时的折磨之后，也是照猫画虎复制粘贴终于搞出来了几个基本的功能了🥲。 以后根据需求慢慢加吧，盲目加功能还是不可取😌。\n","date":"2025-12-25T15:11:10+08:00","permalink":"https://DSJZS.github.io/p/%E5%85%B3%E4%BA%8Ehugo%E6%A1%86%E6%9E%B6%E8%AE%BE%E7%BD%AE%E7%9A%84%E5%90%90%E6%A7%BD/","title":"关于Hugo框架设置的吐槽"},{"content":"脚本介绍 今天创建第一个博客(Hello World)之后，发现部署一个新的博客需要执行诸多繁杂的命令，作为一个Linux用户，肯定是不能忍受的，必须要实现一个简化工具，于是就没事找事花了一点事件编写了一个 bash shell 脚本文件，用于帮助我管理Hugo框架下的博客。\n仅在 Ubuntu 24.04 下进行过测试，不保证所有的场景都没有Bug，必须在阅读脚本文件后自行决定是否使用，本人接收issue但不对产生的问题负责\n主要功能 支持对Hugo博客进行增删查改这些基础操作 支持对Hugo博客用Git推送到仓库(配合Github Action可以丝滑地部署) 使用方法 新增博客(并且使用 vim 对其进行编辑，可选择只创建不编辑) 1 hugo_blog -p ~/my-hugo-site/ -c \u0026#34;我的技术分享\u0026#34; -e vim 删除博客 1 hugo_blog -p ~/my-hugo-site/ -d \u0026#34;过时内容\u0026#34; 查看博客(使用 vscode 进行编辑) 1 hugo_blog -p ~/my-hugo-site/ -r \u0026#34;我的技术分享\u0026#34; 修改博客 1 hugo_blog -p ~/my-hugo-site/ -w \u0026#34;旧文章优化\u0026#34; -e code Git推送 1 hugo_blog -p ~/my-hugo-site/ -g 还有其它的一些功能，具体功能可以参看脚本文件内容 建议配合 alias 取别名使用，如下：\n1 2 3 4 5 6 7 8 MY_BLOG_ROOT_DIR_PATH=\u0026#34;$HOME/blog/dev/\u0026#34; alias new_blog=\u0026#39;hugo_blog -p $MY_BLOG_ROOT_DIR_PATH -e code -c\u0026#39; alias delete_blog=\u0026#39;hugo_blog -p $MY_BLOG_ROOT_DIR_PATH -e code -d\u0026#39; lias write_blog=\u0026#39;hugo_blog -p $MY_BLOG_ROOT_DIR_PATH -e code -w\u0026#39; alias read_blog=\u0026#39;hugo_blog -p $MY_BLOG_ROOT_DIR_PATH -r\u0026#39; alias list_blogs=\u0026#39;hugo_blog -p $MY_BLOG_ROOT_DIR_PATH -l\u0026#39; alias git_push_blogs=\u0026#39;hugo_blog -p $MY_BLOG_ROOT_DIR_PATH -g\u0026#39; alias develop_blogs=\u0026#39;hugo_blog -p $MY_BLOG_ROOT_DIR_PATH -t\u0026#39; 这样增删改查等操作基本上只用输入博客名字就行了\n如果想要避免频繁的 Yes or No 选项，也可以添加 -y 或者 -n 选项来自动选择(我更推荐手动选择)\n脚本获取 我已将脚本上传到我的Github仓库，可以到我的Github仓库进行查看\n也可以执行下述命令直接拉取我的脚本工具仓库(在仓库的 ygtool/shell/hugo_blog/ 目录下 )\n1 git clone https://github.com/DSJZS/ygtool.git 结语 如果你有更好的想法，欢迎交流！\n","date":"2025-12-24T19:46:26+08:00","permalink":"https://DSJZS.github.io/p/%E7%BC%96%E5%86%99%E4%BA%86%E4%B8%80%E4%B8%AA%E7%94%A8%E6%88%B7%E5%BF%AB%E9%80%9F%E5%88%9B%E5%BB%BAhugo%E5%8D%9A%E5%AE%A2%E7%9A%84%E8%84%9A%E6%9C%AC/","title":"编写了一个用户快速创建Hugo博客的脚本"},{"content":"Hi，这是我发布的第一篇博客，欢迎你们访问我的网站！\n","date":"2025-12-24T16:38:24+08:00","permalink":"https://DSJZS.github.io/p/hello-world/","title":"Hello World"}]